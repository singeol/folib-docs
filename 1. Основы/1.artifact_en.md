# What is an Artifact?

## Overview
An **artifact** is a binary produced from source code by compiling and/or packaging. Different programming languages yield different binary formats; these files are typically used to run on servers or serve as build/runtime dependencies. Artifact management is a key part of configuration management and spans the full lifecycle: build, distribution, and deployment.

---

## Basic Concepts of Artifacts
An artifact has the following characteristics:

- **Content type**: class files (e.g., Java bytecode), C object files, text files, binary files, etc.
- **Storage format**: standardized formats supporting multiple languages and scenarios (e.g., JAR, Docker image).
- **Core role**: ensures build reproducibility and dependency security, improving software delivery efficiency.

---

## Common Artifact Formats
By purpose, artifacts can be grouped into two broad categories.

### 1. Dependency dimension
Used to manage packages required for compiling or running the code. Common formats include:

- **Java**: JAR, WAR, EAR
- **JavaScript**: npm packages
- **.NET**: NuGet packages
- **Ruby**: Gems
- **PHP**: Composer dependencies
- **Go**: Go Modules
- **Python**: Wheel, Egg, Conda packages
- **Other languages**: Rust — crates; Perl — CPAN modules; R — CRAN packages; Swift — SPM packages; Dart — Pub packages; Haskell — Cabal; HarmonyOS ohpm — HAR packages

### 2. Finished software package dimension
Final packages intended for deployment or distribution. Common formats include:

- **Generic archives**: ZIP, tar.gz
- **Executables**: .exe, .sh, Android APK
- **Containerized artifacts**: Docker images, Helm packages (charts)
- **System packages**: RPM
- **AI model files**
  - Pre‑trained model files (e.g., TensorFlow SavedModel, PyTorch .pt, ONNX)
  - Inference‑engine files (e.g., TensorRT engine, Core ML model)
- **OTA update packages**
  - Full packages (complete system/app images, e.g., Android OTA zip)
  - Differential packages (only version deltas, e.g., BSDiff)

---

## Classification Scenarios

### By supply scenario
| Type              | Description                                                                 |
|-------------------|-----------------------------------------------------------------------------|
| **First‑party**   | Dependencies among modules within the same system (e.g., internal SDKs between microservices) |
| **Second‑party**  | Internal cross‑team/project dependencies (e.g., shared components provided by other departments) |
| **Third‑party**   | External open‑source or vendor packages (e.g., libraries from Apache, Google) |

## Summary
Artifacts are the core carrier in the software delivery process. By managing them in artifact repositories across the full lifecycle, you can significantly improve build reproducibility, ensure dependency security, and accelerate delivery. Whether it’s development‑time dependencies or final deployment packages, unified artifact management is a cornerstone of modern DevOps practice.
